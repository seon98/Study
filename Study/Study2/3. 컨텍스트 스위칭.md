# 컨텍스트 스위칭(Context Switching)

> 운영체제가 현재 실행 중인 프로세스의 상태(문맥)를 저장하고,
> 다음에 실행할 프로세스의 상태를 불러오는 **문맥 전환** 과정

---

## 왜 필요한가?

멀티태스킹 환경에서는 여러 프로세스가 **CPU 자원을 공유**해야 한다.
운영체제는 **스케줄러**를 통해 프로세스를 빠르게 전환하면서도
각 프로세스의 실행 상태를 보존해야 하므로 Context Switching이 필요하다.

---

## 작동 원리

1. **현재 프로세스의 상태 저장**
   - 레지스터 값 (PC, SP, 기타 레지스터)
   - 프로세스 상태, 메모리 정보 등
   - → 해당 정보를 **PCB(Process Control Block)**에 저장

2. **다음 실행할 프로세스 선택**
   - 스케줄러(Scheduler)가 Ready Queue에서 프로세스를 선택

3. **선택된 프로세스 상태 복원**
   - PCB로부터 이전 상태 불러오기

4. **프로세서에서 실행 재개**

---

## 저장되는 정보 예시

| 항목 | 설명 |
|------|------|
| 프로그램 카운터 (PC) | 다음 실행할 명령어의 주소 |
| 레지스터 상태 | CPU 레지스터 값 (R0 ~ Rn 등) |
| 스택 포인터 (SP) | 현재 함수 호출 위치 정보 |
| 메모리 매핑 정보 | 페이지 테이블, 주소 공간 정보 |
| 입출력 상태 | 열린 파일, 장치 정보 등 |

---

## 오버헤드 (Overhead)

- Context Switching 자체는 **추가 작업**이므로, 성능 저하 요인이 될 수 있다.
- 전환 시간이 너무 자주 발생하면 → **CPU 시간 낭비**

### 오버헤드 줄이는 방법

- 타임 슬라이스 조절
- 프로세스보단 스레드를 활용 (스레드 전환은 비용이 낮음)
- 경량 프로세스(Lightweight Process) 설계

---

## 프로세스와 스레드의 Context Switching 차이

| 항목 | 프로세스 전환 | 스레드 전환 |
|------|----------------|---------------|
| 비용 | 높음 (메모리/레지스터 등 모두 저장) | 낮음 (공유 자원 많음) |
| 주소 공간 | 분리됨 | 공유함 |
| 캐시 영향 | 큼 (TLB Flush 등 발생) | 적음 |
| 전형적 사용 | 멀티프로세스 서버 | 멀티스레드 애플리케이션 |

---

## 실전 예시 (Linux)

- `top`, `htop` 명령어의 `cswch` 항목: context switch 횟수
- 커널 소스 코드: `__switch_to()` 함수에서 수행됨
- 인터럽트나 시스템 콜 후에도 컨텍스트 전환이 발생할 수 있음

---

## 요약

- 컨텍스트 스위칭은 멀티태스킹의 핵심
- PCB를 통해 이전 상태를 저장하고 다음 상태를 불러옴
- 너무 잦은 컨텍스트 전환은 시스템 성능 저하의 원인이 될 수 있음

---
